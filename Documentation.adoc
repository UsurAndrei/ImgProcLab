= Ψηφιακή Επεξεργασία Εικόνας - Εργασία 1
Ρούσου Αντρέι <cs171075@uniwa.gr>
:imagesdir: images
:toc: middle
:toc-title: Πίνακας Περιεχομένων
:source-highlighter: pygments

:cvturl: https://docs.opencv.org/3.4/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab

== Εισαγωγή

Η εργασία έγινε στα πλαίσια του μαθήματος Ψηφιακή Επεξεργασία Εικόνας κατά το ακαδημαικό έτος 2021-2022 και αποτελείται από δύο μέρη συνολικ

Στο πρώτο μέρος, στο πρώτο ερώτημα, γίνεται η ανάπτυξη μιας συνάρτησης, η οποία παίρνει δύο ορίσματα, την αρχική μας είκονα  και μια τιμή από 0 εώς 255. Η συνάρτηση μας με όνομα solarize κάνει ένα απλό pseudo-solarization, δηλαδή δίνοντας μια τιμή και την αρχική μας  εικόνα, όλα τα pixel της εικόνας με τιμή μεγαλύτερη ή ίση με το κατώφλι θα διατηρήσουν την τιμή που είχαν αρχικά, ενώ τα pixels με τιμή μικρότερη του κατωφλιού, θα αντικατασταθούν από pixel με τιμή το συμπλήρωμα του αρχικού, δηλαδή (255 - αρχική τιμή pixel). Αφού αναπτύξουμε την ζητούμενη συνάρτηση, ακολουθούν δυο ερωτήματα δοκιμής και αναπαράστασης των αποτελεσμάτων. 

Το δεύτερο ερώτημα αποτελείται από 3 δοκιμές της λειτουργίας της συνάρτησης μας δίνοντας ως κατώφλι τις τιμές 64, 128, 192. Πριν τις δοκιμές φυσικά η εικόνα μετατρέπεται σε grayscale ώστε να μήν έχουμε περισσότερα κανάλια χρώματος, αλλά μόνο το γκρι. Θα έχουμε ουσιαστικά μια ασπρόμαυρη εικόνα. Στην συνέχεια πάνω στην εικόνα μας, θα γίνει η δοκιμή με τις τιμές που δόθηκαν. 

Τέλος στο τρίτο και τελευταίο ερώτημα, θα γίνει η εμφάνιση και η αποθήκευση των αποτελεσμάτων μας.

== Μεθοδολογία - Μέρος Πρώτο

Παρακάτω η μεθοδολογία που ακολουθήσαμε  και τα αποτελέσματα που λαμβάνουμε για το πρώτο μέρος της εργασίας.

=== Κώδικας

Για το ζητούμενο του πρώτου ερωτήματος έγινε η ανάπτυξη του παρακάτω κώδικα:

.sabbatier.py
[source,python]
--
import cv2
import numpy as np


# Solarize function
def solarize(originalImage, thresValue):
    # Create solarized image, same resolution as original, all pixels value 0 of type uint8 (0-255)
    solarized_image = np.zeros(originalImage.shape, np.uint8)
    # shape returns a tuple of the number of rows, columns, and channels (if the image is color)
    # Select each pixel of the original image
    for colIdx in range(originalImage.shape[0]):
        for rowIdx in range(originalImage.shape[1]):
            # Check how the value of each pixel compares to our threshold value
            if originalImage[colIdx][rowIdx] >= thresValue:
                solarized_image[colIdx][rowIdx] = originalImage[colIdx][rowIdx]
            elif originalImage[colIdx][rowIdx] < thresValue:
                solarized_image[colIdx][rowIdx] = 255 - originalImage[colIdx][rowIdx]
    return solarized_image


# Read image
image = cv2.imread('VilleneuveMonaco1979.jpg')

# Convert from BGR to gray scale
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Show original and  gray scale image
cv2.namedWindow('Orig',cv2.WINDOW_NORMAL)
cv2.imshow('Orig', image)
cv2.namedWindow('Gray',cv2.WINDOW_NORMAL)
cv2.imshow('Gray', gray_image)

# Wait for any key, destroy all windows
# cv2.waitKey(0)
# cv2.destroyAllWindows()

# Save images
cv2.imwrite('Original.jpg', image)
cv2.imwrite('GrayScaleImg.jpg', gray_image)

# Solarize using thresValue = 64
solarized_img64 = solarize(gray_image, 64)

# Solarize using thresValue = 128
solarized_img128 = solarize(gray_image, 128)

# Solarize using thresValue = 192
solarized_img192 = solarize(gray_image, 192)

# Show solarized images
cv2.namedWindow('Solarized image [64]',cv2.WINDOW_NORMAL)
cv2.imshow('Solarized image [64]', solarized_img64)
cv2.namedWindow('Solarized image [128]',cv2.WINDOW_NORMAL)
cv2.imshow('Solarized image [128]', solarized_img128)
cv2.namedWindow('Solarized image [192]',cv2.WINDOW_NORMAL)
cv2.imshow('Solarized image [192]', solarized_img192)

#Save images
cv2.imwrite('Solarized64.jpg', solarized_img64)
cv2.imwrite('Solarized128.jpg', solarized_img128)
cv2.imwrite('Solarized192.jpg', solarized_img192)

# Wait for any key, destroy all windows
cv2.waitKey(0)
cv2.destroyAllWindows()
--


=== Ζητούμενο 1

Η συνάρτηση που ζητήθηκε για το πρώτο ερώτημα είναι η παρακάτω:

[source, python]
--
# Solarize function
def solarize(originalImage, thresValue):
    # Create solarized image, same resolution as original, all pixels value 0 of type uint8 (0-255)
    solarized_image = np.zeros(originalImage.shape, np.uint8)
    # shape returns a tuple of the number of rows, columns, and channels (if the image is color)
    # Select each pixel of the original image
    for colIdx in range(originalImage.shape[0]):
        for rowIdx in range(originalImage.shape[1]):
            # Check how the value of each pixel compares to our threshold value
            if originalImage[colIdx][rowIdx] >= thresValue:
                solarized_image[colIdx][rowIdx] = originalImage[colIdx][rowIdx]
            elif originalImage[colIdx][rowIdx] < thresValue:
                solarized_image[colIdx][rowIdx] = 255 - originalImage[colIdx][rowIdx]
    return solarized_image
--

Η συνάρτηση μας δέχεται δύο ορίσματα, όπως αυτά ζητήθηκαν, την αρχική μας εικόνα και μια τιμή thresValue. Κατά την εκτέλεση της συνάρτησης μας, δημιουργούμε μια εικόνα με όνομα solarized_image, η οποία θα αποτελεί την εικόνα που θα επιστρέψει η συνάρτηση μας.
Η αρχικοποίηση της εικόνας μας, γίνεται με μηδενικά bit με την χρήση της συνάρτησης https://numpy.org/doc/stable/reference/generated/numpy.zeros.html[zeros] της βιβλιοθήκης https://numpy.org/[numpy], 
αρχικοποιόντας έτσι την εικόνα μας, με μηδενικά bit, σε ίδιο μέγεθος με την αρχική εικόνα που δίνουμε για όρισμα. Δίνουμε στην συνάρτηση zeros μας και τον τύπο δεδομένων uint8, unsigned integer των 8-bit δηλαδή, εύρως τιμών 0 εώς 255, δηλαδή οι τιμές
που μπορεί να πάρει ένα pixel. 

Έχει ενδιαφέρον να γίνει μια ανάλυση της συνάρτησης shape. Η συνάρτηση αυτή επιστρέφει ένα tupple με 3 στοιχεία, των αριθμό των γραμμών, των στυλών και τέλος τα κανάλια. Αυτό έχει σημασία διότι με ευκολία μπορούμε με μια for να πάρουμε κάθε γραμμή της εικόνας και με
μια άλλη for κάθε στύλη, όπως ακριβώς θα κάναμε αν θέλαμε να έχουμε πρόσβαση σε κάθε στοιχείο ενός πίνακα δυο διαστάσεων. 

Αφού λοιπόν μπορούμε να το κάνουμε αυτό, μένει μόνο να συγκρίνουμε την τιμή του κάθε pixel της αρχικής εικόνας με την τιμή που έχουμε δώσει για
το κατώφλι. Αν είναι μεγαλύτερη, το pixel κρατάει την τιμή που είχε, δηλαδή στην νέα εικόνα μας κάνουμε εκχώρηση της τιμής του pixel της αρχικής εικόνας στο αντίστοιχο pixel της εικόνας που θα επιστρέψει η συνάρτηση μας.
Αλλίως, αν είναι μικρότερη, εκχωρούμε στο pixel την τιμή (255 - την τιμή του pixel της αρχικής εικόνας), το συμπλήρωμα δηλαδή όπως ζητήθηκε στην εκφώνηση. Τέλος φυσικά αφού έχει γίνει ο έλεγχος σε κάθε pixel, η συνάρτηση μας επιστρέψει την solarized εικόνα μας.

=== Ζητούμενο 2

Για την εφαρμογή της συνάρτησης μας σε μια εικόνα, ακολουθούμε τα παρακάτω βήματα:

Αρχικά θα «ανοίξουμε» την αρχική μας εικόνα με την χρήση της συνάρτησης https://docs.opencv.org/4.x/d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56[imread] της βιβλιοθήκης https://docs.opencv.org/4.x/index.html[OpenCV]. 
H συνάρτηση imread δέχεται σαν όρισμα το όνομα της εικόνας μας. Για την δοκιμή θα χρησιμοποιήσουμε μια εικόνα του μεγάλου Gilles Villeneuve οδηγόντας την Ferrari 312T4 στο Gran Prix του Monaco το 1979. Διαβάζουμε την εικόνα με τον παρακάτω τρόπο:

[source, python]
--
# Read image
image = cv2.imread('VilleneuveMonaco1979.jpg')
--

[NOTE]
Στην imread μπορούμε να προσθέσουμε σαν όρισμα και flag τα κανάλια χρώματος που θέλουμε. Παρατηρόντας στο documentation με flag 2 η εικόνα μας θα μπορούσε να διαβαστεί και να γίνει η ζητούμενη μετατροπή σε gray-scale κατευθείαν.


Όμως η μετατροπή μπορεί να γίνει και με τον παρακάτω τρόπο:

[source, python]
--
# Convert from BGR to gray scale
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
--

Χρησιμοποιούμε δηλαδή την συνάρτηση {cvturl}[cvtColor] της βιβλιοθήκης OpenCV. 
Η συνάρτηση αυτή δέχεται σαν όρισμα την εικόνα μας και το αντίστοιχο enum που αντιστοιχεί σε μετατροπή απο τρία κανάλια χρώματος σε grayscale. Η συνάρτηση μας επιστρέφει την grayscale εικόνα η οποία θα μπει στην μεταβλητή gray_image μας.

[NOTE]
Η μεταβλητή gray_image μπορεί να περαστεί και σαν όρισμα κατά την κλήση της συνάρτησης cvtColor για την αποθήκευση της grayscale εικόνας μας.

 
Πλέον στην μεταβλητή gray_image θα έχουμε ίδια εικόνα με την αρχική, μόνο που θα είναι σε grayscale όπως μας ζητήθηκε. Αρκεί τώρα να δημιουργήσουμε τρεις μεταβλητές για τις solarized εικόνες και να καλέσουμε την συνάρτηση μας με το ζητούμενο κατώφλι.
Η διαδικασία γίνεται παρακάτω:

[source, python]
--
# Solarize using thresValue = 64
solarized_img64 = solarize(gray_image, 64)

# Solarize using thresValue = 128
solarized_img128 = solarize(gray_image, 128)

# Solarize using thresValue = 192
solarized_img192 = solarize(gray_image, 192)
--

Πλέον έχουμε τρεις μεταβλητές, solarized_img64, solarized_img128 και solarized_img192 που περιέχουν την πληροφορία για τρεις εικόνες, αποτέλεσμα την κλήσης της συνάρτησης μας με κατώφλι 64, 128 και 192 αντίστοιχα. Κατά την κλήση, δίνουμε
όπως αναφέραμε και πριν, την αρχική μας εικόνα (σε grayscale) και το κατώφλι για ορίσματα.

Απομένει λοιπόν η εμφάνηση των αποτελεσμάτων, η οποία γίνεται στις παρακάτω γραμμές:

[source, python]
--
# Show solarized images
cv2.namedWindow('Solarized image [64]',cv2.WINDOW_NORMAL)
cv2.imshow('Solarized image [64]', solarized_img64)
cv2.namedWindow('Solarized image [128]',cv2.WINDOW_NORMAL)
cv2.imshow('Solarized image [128]', solarized_img128)
cv2.namedWindow('Solarized image [192]',cv2.WINDOW_NORMAL)
cv2.imshow('Solarized image [192]', solarized_img192)
--

Για την εμφάνιση δημιουργούμε ένα παράθυρο με την συνάρτηση https://docs.opencv.org/4.x/d7/dfc/group__highgui.html#ga5afdf8410934fd099df85c75b2e0888b[namedWindow] της βιβλιοθήκης OpenCV, δίνοντας για όρισμα το όνομα που θέλουμε για το παράθυρο και ένα flag, στην περίπτωση μας το WINDOW_NORMAL που αντιστοιχεί σε παράθυρο του οποίου μπορούμε να αλλάξουμε το μέγεθος. Η διαδικάσια γίνεται τρεις φορές για κάθε παράθυρο.
Μετά από την δημιουργία του παραθύρου, με την χρήση της συνάρτησης https://docs.opencv.org/4.x/d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563[imshow] της βιβλιοθήκης OpenCV, δίνοντας για ορίσματα το όνομα του παραθύρου που δημιουργήσαμε σε κάθε περίπτωση προηγουμένως και την είκονα. Η ίδια διαδικασία γίνεται τρεις φορές για κάθε εικόνα που έχουμε στο παράδειγμα μας.

=== Ζητούμενο 3



== Μέρος Δεύτερο


