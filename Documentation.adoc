= Ψηφιακή Επεξεργασία Εικόνας - Εργασία 1
Ρούσου Αντρέι <cs171075@uniwa.gr>
:imagesdir: images
:toc: middle
:toc-title: Πίνακας Περιεχομένων
:source-highlighter: pygments
:figure-caption: Image 

:cvturl: https://docs.opencv.org/3.4/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab
:urlnamedwindow: https://docs.opencv.org/4.x/d7/dfc/group__highgui.html#ga5afdf8410934fd099df85c75b2e0888b
:urlimshow: https://docs.opencv.org/4.x/d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563
:urlimwrite: https://docs.opencv.org/4.x/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce

== Εισαγωγή

Η εργασία έγινε στα πλαίσια του μαθήματος Ψηφιακή Επεξεργασία Εικόνας κατά το ακαδημαικό έτος 2021-2022 και αποτελείται από δύο μέρη συνολικά.

[discrete]
=== Mέρος πρώτο

Στο πρώτο μέρος, στο πρώτο ερώτημα, γίνεται η ανάπτυξη μιας συνάρτησης, η οποία παίρνει δύο ορίσματα, την αρχική μας είκονα  και μια τιμή από 0 εώς 255. Η συνάρτηση μας με όνομα solarize κάνει ένα απλό pseudo-solarization, δηλαδή δίνοντας μια τιμή και την αρχική μας  εικόνα, όλα τα pixel της εικόνας με τιμή μεγαλύτερη ή ίση με το κατώφλι θα διατηρήσουν την τιμή που είχαν αρχικά, ενώ τα pixels με τιμή μικρότερη του κατωφλιού, θα αντικατασταθούν από pixel με τιμή το συμπλήρωμα του αρχικού, δηλαδή (255 - αρχική τιμή pixel). Αφού αναπτύξουμε την ζητούμενη συνάρτηση, ακολουθούν δυο ερωτήματα δοκιμής και αναπαράστασης των αποτελεσμάτων. 

Το δεύτερο ερώτημα αποτελείται από 3 δοκιμές της λειτουργίας της συνάρτησης μας δίνοντας ως κατώφλι τις τιμές 64, 128, 192. Πριν τις δοκιμές φυσικά η εικόνα μετατρέπεται σε grayscale ώστε να μήν έχουμε περισσότερα κανάλια χρώματος, αλλά μόνο το γκρι. Θα έχουμε ουσιαστικά μια ασπρόμαυρη εικόνα. Στην συνέχεια πάνω στην εικόνα μας, θα γίνει η δοκιμή με τις τιμές που δόθηκαν. 

Τέλος στο τρίτο και τελευταίο ερώτημα, θα γίνει η εμφάνιση και η αποθήκευση των αποτελεσμάτων μας.

[discrete]
=== Mέρος δεύτερο

Το δεύτερο μέρος αρχίζει με παρόμοια διαδικασία. Στο πρώτο ερώτημα δίνουμε μια εικόνα και κάνουμε την μετατροπή σε grayscale. Ακολουθεί το δεύτερο ερώτημα, το οποίο αφορά εισαγωγή θορύβου. Σε αυτό το ερώτημα το πρώτο ζητούμενο αφορά την εισαγωγή θορύβου salt and pepper, δηλαδή θορύβου που αποτελείται από μαύρα (0) και άσπρα pixels (255) τα οποία εμφανίζονται με συγκεκριμένη πιθανότητα για κάθε pixel (10% να γίνει το pixel μας άσπρο ή μαύρο).

Για το δεύτερο ζητούμενο του δεύτερου ερωτήματος, πρέπει να εισάγουμε έναν δικό μας θόρυβο στην εικόνα, οποιονδήποτε εκτός απο Gaussian Noise. Για το συγκεκριμένο υποερώτημα έγινε η επιλογή Shot noise, δηλαδή θορύβου που σχετίζεται με την κατανομή Poisson. Δηλαδή με τον κατάλληλο τρόπο τα pixels την τελικής εικόνας μας που θα έχει επηρεαστεί από τον θόρυβο, θα ακολουθούν κατανομή Poisson.

Στο τρίτο ερώτημα μας ζητείται να εμφανίζουμε τις εικόνες, με τον θόρυβο που έχουμε εισάγει.

Στο τέταρτο ερώτημα μας ζητείται να αφαιρέσουμε τον θόρυβο που έχουμε εισάγει στα πρηγούμενα ερωτήματα με τρία διαφορετικά φίλτρα τα οποία τα επιλέγουμε εμέις. Για την υλόποιηση έχει γίνει η επιλογή των φίλτων mean blur, median blur και gaussian blur.

Στο πέμπτο ερώτημα απλά εμφανίζουμε της εικόνες, αφού τις έχουμε περάσει με τα φίλτρα τις επιλογής μας. Τα αποτελέσματα θα αναλυθούν παρακάτω.

Τέλος, το έκτο ερώτημα του δεύτερου μέρους μας ζητάει να συγκρίνουμε τις τελικές εικόνες, τις οποίες έχουμε επεξεργαστεί με τα φίλτρα μας προσπαθόντας να αφαιρέσουμε τον θόρυβο με την αρχική μας εικόνα. Για την σύγκριση αυτή ζητείται να χρησιμοποιήσουμε δυο μετρικές. Στο πρώτο υποερώτημα ζητείται η χρήση του Structural Similarity Index Measure (SSIM), μετρική που χρησιμοποιείται πολύ για σύγκριση δυο εικόνων.

Στο δεύτερο υποερώτημα, ζητείται να γίνει χρήση μιας μετρικής της επιλογής μας.Θα γίνει χρήση για αυτή την περίπτωση, του Mean Square Error (MSE), του Μέσου Τετραγωνικού Σφάλματος δηλαδή.

== Μεθοδολογία - Μέρος Πρώτο

Παρακάτω η μεθοδος που ακολουθήσαμε για την απάντηση των ερωτημάτων και τα αποτελέσματα που λαμβάνουμε για το πρώτο μέρος της εργασίας.

=== Κώδικας

Για τα ζητούμενα του πρώτου μέρους έγινε η ανάπτυξη του παρακάτω κώδικα:

.sabbatier.py
[source,python]
--
import cv2
import numpy as np


# Solarize function
def solarize(originalImage, thresValue):
    # Create solarized image, same resolution as original, all pixels value 0 of type uint8 (0-255)
    solarized_image = np.zeros(originalImage.shape, np.uint8)
    # shape returns a tuple of the number of rows, columns, and channels (if the image is color)
    # Select each pixel of the original image
    for colIdx in range(originalImage.shape[0]):
        for rowIdx in range(originalImage.shape[1]):
            # Check how the value of each pixel compares to our threshold value
            if originalImage[colIdx][rowIdx] >= thresValue:
                solarized_image[colIdx][rowIdx] = originalImage[colIdx][rowIdx]
            elif originalImage[colIdx][rowIdx] < thresValue:
                solarized_image[colIdx][rowIdx] = 255 - originalImage[colIdx][rowIdx]
    return solarized_image


# Read image
image = cv2.imread('VilleneuveMonaco1979.jpg')

# Convert from BGR to gray scale
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Show original and  gray scale image
cv2.namedWindow('Orig',cv2.WINDOW_NORMAL)
cv2.imshow('Orig', image)
cv2.namedWindow('Gray',cv2.WINDOW_NORMAL)
cv2.imshow('Gray', gray_image)

# Wait for any key, destroy all windows
# cv2.waitKey(0)
# cv2.destroyAllWindows()

# Save images
cv2.imwrite('Original.jpg', image)
cv2.imwrite('GrayScaleImg.jpg', gray_image)

# Solarize using thresValue = 64
solarized_img64 = solarize(gray_image, 64)

# Solarize using thresValue = 128
solarized_img128 = solarize(gray_image, 128)

# Solarize using thresValue = 192
solarized_img192 = solarize(gray_image, 192)

# Show solarized images
cv2.namedWindow('Solarized image [64]',cv2.WINDOW_NORMAL)
cv2.imshow('Solarized image [64]', solarized_img64)
cv2.namedWindow('Solarized image [128]',cv2.WINDOW_NORMAL)
cv2.imshow('Solarized image [128]', solarized_img128)
cv2.namedWindow('Solarized image [192]',cv2.WINDOW_NORMAL)
cv2.imshow('Solarized image [192]', solarized_img192)

#Save images
cv2.imwrite('Solarized64.jpg', solarized_img64)
cv2.imwrite('Solarized128.jpg', solarized_img128)
cv2.imwrite('Solarized192.jpg', solarized_img192)

# Wait for any key, destroy all windows
cv2.waitKey(0)
cv2.destroyAllWindows()
--

Στην αρχή του κώδικα κάνουμε import τις βιβλιοθήκες που θα χρειαστούμε, τις https://pypi.org/project/opencv-python/[OpenCV] και https://numpy.org/[NumPY] αντίστοιχα.

[source, python]
--
import cv2
import numpy as np
--

=== Ερώτημα 1

Η συνάρτηση που ζητήθηκε για το πρώτο ερώτημα είναι η παρακάτω:

[source, python]
--
# Solarize function
def solarize(originalImage, thresValue):
    # Create solarized image, same resolution as original, all pixels value 0 of type uint8 (0-255)
    solarized_image = np.zeros(originalImage.shape, np.uint8)
    # shape returns a tuple of the number of rows, columns, and channels (if the image is color)
    # Select each pixel of the original image
    for colIdx in range(originalImage.shape[0]):
        for rowIdx in range(originalImage.shape[1]):
            # Check how the value of each pixel compares to our threshold value
            if originalImage[colIdx][rowIdx] >= thresValue:
                solarized_image[colIdx][rowIdx] = originalImage[colIdx][rowIdx]
            elif originalImage[colIdx][rowIdx] < thresValue:
                solarized_image[colIdx][rowIdx] = 255 - originalImage[colIdx][rowIdx]
    return solarized_image
--

Η συνάρτηση μας δέχεται δύο ορίσματα, όπως αυτά ζητήθηκαν, την αρχική μας εικόνα και μια τιμή thresValue. Κατά την εκτέλεση της συνάρτησης μας, δημιουργούμε μια εικόνα με όνομα solarized_image, η οποία θα αποτελεί την εικόνα που θα επιστρέψει η συνάρτηση μας.
Η αρχικοποίηση της εικόνας μας, γίνεται με μηδενικά bit με την χρήση της συνάρτησης https://numpy.org/doc/stable/reference/generated/numpy.zeros.html[zeros] της βιβλιοθήκης https://numpy.org/[numpy], 
αρχικοποιόντας έτσι την εικόνα μας, με μηδενικά bit, σε ίδιο μέγεθος με την αρχική εικόνα που δίνουμε για όρισμα. Δίνουμε στην συνάρτηση zeros μας και τον τύπο δεδομένων uint8, unsigned integer των 8-bit δηλαδή, εύρως τιμών 0 εώς 255, δηλαδή οι τιμές
που μπορεί να πάρει ένα pixel. 

Έχει ενδιαφέρον να γίνει μια ανάλυση της συνάρτησης shape. Η συνάρτηση αυτή επιστρέφει ένα tupple με 3 στοιχεία, των αριθμό των γραμμών, των στυλών και τέλος τα κανάλια. Αυτό έχει σημασία διότι με ευκολία μπορούμε με μια for να πάρουμε κάθε γραμμή της εικόνας και με
μια άλλη for κάθε στύλη, όπως ακριβώς θα κάναμε αν θέλαμε να έχουμε πρόσβαση σε κάθε στοιχείο ενός πίνακα δυο διαστάσεων. 

Αφού λοιπόν μπορούμε να το κάνουμε αυτό, μένει μόνο να συγκρίνουμε την τιμή του κάθε pixel της αρχικής εικόνας με την τιμή που έχουμε δώσει για
το κατώφλι. Αν είναι μεγαλύτερη, το pixel κρατάει την τιμή που είχε, δηλαδή στην νέα εικόνα μας κάνουμε εκχώρηση της τιμής του pixel της αρχικής εικόνας στο αντίστοιχο pixel της εικόνας που θα επιστρέψει η συνάρτηση μας.
Αλλίως, αν είναι μικρότερη, εκχωρούμε στο pixel την τιμή (255 - την τιμή του pixel της αρχικής εικόνας), το συμπλήρωμα δηλαδή όπως ζητήθηκε στην εκφώνηση. Τέλος φυσικά αφού έχει γίνει ο έλεγχος σε κάθε pixel, η συνάρτηση μας επιστρέψει την solarized εικόνα μας.

=== Ερώτημα 2

Για την εφαρμογή της συνάρτησης μας σε μια εικόνα, ακολουθούμε τα παρακάτω βήματα:

Αρχικά θα «ανοίξουμε» την αρχική μας εικόνα με την χρήση της συνάρτησης https://docs.opencv.org/4.x/d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56[imread] της βιβλιοθήκης https://docs.opencv.org/4.x/index.html[OpenCV]. 
H συνάρτηση imread δέχεται σαν όρισμα το όνομα της εικόνας μας. Για την δοκιμή θα χρησιμοποιήσουμε μια εικόνα του μεγάλου Gilles Villeneuve οδηγόντας την Ferrari 312T4 στο Gran Prix του Monaco το 1979. Διαβάζουμε την εικόνα με τον παρακάτω τρόπο:

[source, python]
--
# Read image
image = cv2.imread('VilleneuveMonaco1979.jpg')
--

[NOTE]
Στην imread μπορούμε να προσθέσουμε σαν όρισμα και flag τα κανάλια χρώματος που θέλουμε. Παρατηρόντας στο documentation με flag 2 η εικόνα μας θα μπορούσε να διαβαστεί και να γίνει η ζητούμενη μετατροπή σε gray-scale κατευθείαν.


Όμως η μετατροπή μπορεί να γίνει και με τον παρακάτω τρόπο:

[source, python]
--
# Convert from BGR to gray scale
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
--

Χρησιμοποιούμε δηλαδή την συνάρτηση {cvturl}[cvtColor] της βιβλιοθήκης OpenCV. 
Η συνάρτηση αυτή δέχεται σαν όρισμα την εικόνα μας και το αντίστοιχο enum που αντιστοιχεί σε μετατροπή απο τρία κανάλια χρώματος σε grayscale. Η συνάρτηση μας επιστρέφει την grayscale εικόνα η οποία θα μπει στην μεταβλητή gray_image μας.

[NOTE]
Η μεταβλητή gray_image μπορεί να περαστεί και σαν όρισμα κατά την κλήση της συνάρτησης cvtColor για την αποθήκευση της grayscale εικόνας μας.

 
Πλέον στην μεταβλητή gray_image θα έχουμε ίδια εικόνα με την αρχική, μόνο που θα είναι σε grayscale όπως μας ζητήθηκε. Αρκεί τώρα να δημιουργήσουμε τρεις μεταβλητές για τις solarized εικόνες και να καλέσουμε την συνάρτηση μας με το ζητούμενο κατώφλι.
Η διαδικασία γίνεται παρακάτω:

[source, python]
--
# Solarize using thresValue = 64
solarized_img64 = solarize(gray_image, 64)

# Solarize using thresValue = 128
solarized_img128 = solarize(gray_image, 128)

# Solarize using thresValue = 192
solarized_img192 = solarize(gray_image, 192)
--

Πλέον έχουμε τρεις μεταβλητές, solarized_img64, solarized_img128 και solarized_img192 που περιέχουν την πληροφορία για τρεις solarized εικόνες μας, αποτέλεσμα την κλήσης της συνάρτησης μας με κατώφλι 64, 128 και 192 αντίστοιχα. Κατά την κλήση, δίνουμε
όπως αναφέραμε και πριν, την αρχική μας εικόνα (σε grayscale) και το κατώφλι για ορίσματα.

=== Ερώτημα 3

Απομένει λοιπόν η εμφάνηση των αποτελεσμάτων, η οποία γίνεται στις παρακάτω γραμμές:

[source, python]
--
# Show solarized images
cv2.namedWindow('Solarized image [64]',cv2.WINDOW_NORMAL)
cv2.imshow('Solarized image [64]', solarized_img64)
cv2.namedWindow('Solarized image [128]',cv2.WINDOW_NORMAL)
cv2.imshow('Solarized image [128]', solarized_img128)
cv2.namedWindow('Solarized image [192]',cv2.WINDOW_NORMAL)
cv2.imshow('Solarized image [192]', solarized_img192)
--

Για την εμφάνιση δημιουργούμε ένα παράθυρο με την συνάρτηση {urlnamedwindow}[namedWindow] της βιβλιοθήκης OpenCV, δίνοντας για όρισμα το όνομα που θέλουμε για το παράθυρο και ένα flag, στην περίπτωση μας το WINDOW_NORMAL που αντιστοιχεί σε παράθυρο του οποίου μπορούμε να αλλάξουμε το μέγεθος. Η διαδικάσια γίνεται τρεις φορές για κάθε παράθυρο.
Μετά από την δημιουργία του παραθύρου, με την χρήση της συνάρτησης {urlimshow}[imshow] της βιβλιοθήκης OpenCV, δίνοντας για ορίσματα το όνομα του παραθύρου που δημιουργήσαμε σε κάθε περίπτωση προηγουμένως και την είκονα. Η ίδια διαδικασία γίνεται τρεις φορές για κάθε εικόνα που έχουμε στο παράδειγμα μας.

Για σύγκριση, αν και δεν υπάρχει στα ζητούμενα, εμφανίζουμε και την original εικόνα, στην αρχική μορφή και σε grayscale με αντίστοιχο τρόπο στις παρακάτω γραμμές:

[source, python]
--
# Show original and  gray scale image
cv2.namedWindow('Orig',cv2.WINDOW_NORMAL)
cv2.imshow('Orig', image)
cv2.namedWindow('Gray',cv2.WINDOW_NORMAL)
cv2.imshow('Gray', gray_image)
--

Παρακάτω τα αποτελέσματα που λαμβάνουμε:

Παρακάτω η αρχική μας εικόνα, στην αρχική της μορφή:

.Original Image
image::Original.jpg[]

Η αρχική μας εικόνα, σε μορφή grayscale. Παρατηρούμε ότι υπάρχει ένα κανάλι (γκρί) και λείπουν τα χρώματα.

.GrayScale Image
image::GrayScaleImg.jpg[]

Παρακάτω η αρχική μας εικόνα, solarized με κατώφλι 64. Παρατηρούμε ότι τα μαύρα pixels έχουν αντικατασταθεί με άσπρα και κάποια πολύ σκούρα έχουν αντικατασταθεί με το συμπλήρωμα τους αν και δεν φαίνεται πολύ στο μάτι μας.

.Solarized Image (64)
image::Solarized64.jpg[]

Η εικόνα παρακάτω βλέπουμε πλέον έχει χάσει αρκετά από τα πολύ σκούρα pixels καθώς το κατώφλι είναι σχεδόν στη μέση, οπότε ακόμα και το συμπλήρωμα με το οποίο θα αντικαταστήσουμε πολλά από τα pixels είναι επίσης ανοιχτόχρωμο.

.Solarized Image (128)
image::Solarized128.jpg[]

Τέλος παρακάτω η εικόνα solarized με κατώφλι 192, βλέπουμε ότι σχεδόν όλα τα σκούρα pixels έχουν αντικατασταθεί, ενω ορισμένα που είχαν σχετικά ανοιχτόχρωμη τιμή έχουν τονιστεί πιο έντονα, το οποίο είναι λογικό, καθώς με υψηλό κατώφλι, το συμπλήρωμα ορισμένων ανοιχτόχρωμων pixels θα είναι σκουρόχρωμο.

.Solarized Image (192)
image::Solarized192.jpg[]

Σε κάθε περίπτωση η αποθήκευση της κάθε εικόνας γίνεται με την χρήση της συνάρτησης {urlimwrite}[imwrite] της βιβλιοθήκης OpenCV. Η συνάρτηση δέχεται σαν όρισμα το όνομα της εικόνας που θα έχει το αρχείο και την μεταβλητή της εικόνας μας.
Η αποθήκευση γίνεται μια φορά για την original και την grayscale και ας μην ζητήθηκε αλλά φυσικά και στα αποτελέσματα μας όπως βλέπουμε στις παρακάτω γραμμές:

[source, python]
--
# Save images
cv2.imwrite('Original.jpg', image)
cv2.imwrite('GrayScaleImg.jpg', gray_image)
--

[source, python]
--
#Save images
cv2.imwrite('Solarized64.jpg', solarized_img64)
cv2.imwrite('Solarized128.jpg', solarized_img128)
cv2.imwrite('Solarized192.jpg', solarized_img192)
--

Θα πρέπει μετά την εκτέλεση των παραπάνω γραμμών να υπάρχουν οι εικόνες ως αρχεία στον δίσκο μας.

== Μεθοδολογία - Μέρος Δεύτερο

Παρακάτω η μέθοδος που ακολουθήσαμε για την λύση των ερωτημάτων και τα αποτελέσματα που λαμβάνουμε για το δεύτερο μέρος της εργασίας.

=== Κώδικας

Για τα ζητούμενα του δεύτερου μέρους έγινε η ανάπτυξη του παρακάτω κώδικα:

.noise.py
[source, python]
--
import random
import cv2
import numpy as np
from skimage.metrics import structural_similarity as ssim
from skimage.metrics import mean_squared_error

# Read image
image = cv2.imread('Subaru555.jpg')

# Convert from BGR to gray scale
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

cv2.namedWindow('Gray Image', cv2.WINDOW_NORMAL)
cv2.imshow('Gray Image', gray_image)
cv2.imwrite('GrayScaleImg.jpg', gray_image)

# Salt and Pepper with probability 10% (10% white, 10% black)
spnoisy_img = np.zeros(gray_image.shape, np.uint8)

# Select each pixel of the original image
for colIdx in range(gray_image.shape[0]):
    for rowIdx in range(gray_image.shape[1]):
        # Generate a random number in the semi-open range [0.0 1.0)
        rand = random.random()
        # If the number is less than 0.1 (10% possibility), turn the pixel black 0
        if rand < 0.1:
            spnoisy_img[colIdx][rowIdx] = 0
        # Else if the number is greater than 0.9 (10% possibility), turn the pixel white 255
        elif rand > 0.9:
            spnoisy_img[colIdx][rowIdx] = 255
        # Else just keep the original value
        else:
            spnoisy_img[colIdx][rowIdx] = gray_image[colIdx][rowIdx]

# Show Salt and Pepper noisy image, save in same directory
cv2.namedWindow('Salt and Pepper',cv2.WINDOW_NORMAL)
cv2.imshow('Salt and Pepper', spnoisy_img)
cv2.imwrite('SaltAndPepper.jpg', spnoisy_img)

# Create noise using numpy.random poisson function, type uint8 so pixels get 0-255 values
noise = np.random.poisson(gray_image).astype(np.uint8)
# Add noise to initial grayscale image
poisson_img = (gray_image + noise)

# Show image with Shot noise, save in same directory
cv2.namedWindow('Shot Noise', cv2.WINDOW_NORMAL)
cv2.imshow('Shot Noise', poisson_img)
cv2.imwrite('ShotNoise.jpg', poisson_img)

# Use mean filter on images, kernel size 5x5
meanFilterSP = cv2.blur(spnoisy_img, (5, 5))
meanFilterPoisson = cv2.blur(poisson_img, (5, 5))

# Use median filter on images, kernel size 5x5
medianFilterSP = cv2.medianBlur(spnoisy_img, 5)
medianFilterPoisson = cv2.medianBlur(poisson_img, 5)

# Use gaussian filter on images, kernel size 5x5
gaussianFilterSP = cv2.GaussianBlur(spnoisy_img, (5, 5), 0, 0)
gaussianFilterPoisson = cv2.GaussianBlur(poisson_img, (5, 5), 0, 0)

# Show image after mean filter, save in same directory
cv2.namedWindow('Mean Filter (Salt & Pepper)', cv2.WINDOW_NORMAL)
cv2.imshow('Mean Filter (Salt & Pepper)', meanFilterSP)
cv2.imwrite('MeanFilteredSP.jpg', meanFilterSP)
cv2.namedWindow('Mean Filter (Shot)', cv2.WINDOW_NORMAL)
cv2.imshow('Mean Filter (Shot)', meanFilterPoisson)
cv2.imwrite('MeanFilteredPoisson.jpg', meanFilterPoisson)

# Show image after median filter, save in same directory
cv2.namedWindow('Median Filter (Salt & Pepper)', cv2.WINDOW_NORMAL)
cv2.imshow('Median Filter (Salt & Pepper)', medianFilterSP)
cv2.imwrite('MedianFilteredSP.jpg', medianFilterSP)
cv2.namedWindow('Median Filter (Shot)', cv2.WINDOW_NORMAL)
cv2.imshow('Median Filter (Shot)', medianFilterPoisson)
cv2.imwrite('MedianFilteredPoisson.jpg', medianFilterPoisson)

# Show image after gaussian filter, save in same directory
cv2.namedWindow('Gaussian Filter (Salt & Pepper)', cv2.WINDOW_NORMAL)
cv2.imshow('Gaussian Filter (Salt & Pepper)', gaussianFilterSP)
cv2.imwrite('GaussianFilteredSP.jpg', gaussianFilterSP)
cv2.namedWindow('Gaussian Filter (Shot)', cv2.WINDOW_NORMAL)
cv2.imshow('Gaussian Filter (Shot)', gaussianFilterPoisson)
cv2.imwrite('GaussianFilteredPoisson.jpg', gaussianFilterPoisson)

cv2.waitKey(0)
cv2.destroyAllWindows()

# Print Similarity Scores
sim_score = ssim(gray_image, meanFilterSP)
mse_score = mean_squared_error(gray_image, meanFilterSP)
print('Salt & Pepper: Original - Mean Filtered SSID:{:.3f}'.format(sim_score))
print('Salt & Pepper: Original - Mean Filtered MSE:{:.3f}'.format(mse_score))
sim_score = ssim(gray_image, medianFilterSP)
mse_score = mean_squared_error(gray_image, medianFilterSP)
print('Salt & Pepper: Original - Median Filtered SSID:{:.3f}'.format(sim_score))
print('Salt & Pepper: Original - Median Filtered MSE:{:.3f}'.format(mse_score))
sim_score = ssim(gray_image, gaussianFilterSP)
mse_score = mean_squared_error(gray_image, gaussianFilterSP)
print('Salt & Pepper: Original - Gauss Filtered SSID:{:.3f}'.format(sim_score))
print('Salt & Pepper: Original - Gauss Filtered MSE:{:.3f}'.format(mse_score))

sim_score = ssim(gray_image, meanFilterPoisson)
mse_score = mean_squared_error(gray_image, meanFilterPoisson)
print('Shot: Original - Mean Filtered SSID:{:.3f}'.format(sim_score))
print('Shot: Original - Mean Filtered MSE:{:.3f}'.format(mse_score))
sim_score = ssim(gray_image, medianFilterPoisson)
mse_score = mean_squared_error(gray_image, medianFilterPoisson)
print('Shot: Original - Median Filtered SSID:{:.3f}'.format(sim_score))
print('Shot: Original - Median Filtered MSE:{:.3f}'.format(mse_score))
sim_score = ssim(gray_image, gaussianFilterPoisson)
mse_score = mean_squared_error(gray_image, gaussianFilterPoisson)
print('Shot: Original - Gauss Filtered SSID:{:.3f}'.format(sim_score))
print('Shot: Original - Gauss Filtered MSE:{:.3f}'.format(mse_score))
--

Στην αρχή κάνουμε import τις βιβλιοθήκες που θα χρησιμοποιήσουμε, τις https://pypi.org/project/opencv-python/[OpenCV], https://numpy.org/[NumPY], https://docs.python.org/3/library/random.html[Random] και ορισμένες χρήσιμες συναρτήσεις από τη https://scikit-image.org/[SciKit-Image].

[source, python]
--
import random
import cv2
import numpy as np
from skimage.metrics import structural_similarity as ssim
from skimage.metrics import mean_squared_error
--

=== Ερώτημα 1

Στο πρώτο ερώτημα μας ζητείται να διαβάσουμε μια εικόνα της επιλογής μας και να τη μετατρέψουμε σε grayscale.
Θα «ανοίξουμε» την αρχική μας εικόνα με τη χρήση της συνάρτησης https://docs.opencv.org/4.x/d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56[imread] όπως και στο προηγούμενο μέρος της εργασίας.
Η μετατροπή σε grayscale θα γίνει ξανά με την χρήση της {cvturl}[cvtColor] της βιβλιοθήκης OpenCV αντίστοιχα.

Παρακάτω οι γραμμές κώδικα στις οποίες διαβάζουμε και μετατρέπουμε την εικόνα:

[source, python]
--
# Read image
image = cv2.imread('Subaru555.jpg')

# Convert from BGR to gray scale
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
--

Για το συγκεκριμένο μέρος της εργασίας θα χρησιμοποιήσουμε για τις δοκιμές μας μια εικόνα του Colin McRae στο Rally της Αργεντινής το 1998 οδηγόντας το επικό Subaru Impreza του.

=== Ερώτημα 2

Στο δεύτερο ερώτημα εισάγουμε τους δύο θορύβους.

[Discrete]
==== Salt & Pepper

Παρακάτω ο κώδικας για την εισαγωγή Salt and Pepper θορύβου 10%:

[source, python]
--
# Salt and Pepper with probability 10% (10% white, 10% black)
spnoisy_img = np.zeros(gray_image.shape, np.uint8)

# Select each pixel of the original image
for colIdx in range(gray_image.shape[0]):
    for rowIdx in range(gray_image.shape[1]):
        # Generate a random number in the semi-open range [0.0 1.0)
        rand = random.random()
        # If the number is less than 0.05 (5% possibility), turn the pixel black 0
        if rand < 0.05:
            spnoisy_img[colIdx][rowIdx] = 0
        # Else if the number is greater than 0.95 (5% possibility), turn the pixel white 255
        elif rand > 0.95:
            spnoisy_img[colIdx][rowIdx] = 255
        # Else just keep the original value
        else:
            spnoisy_img[colIdx][rowIdx] = gray_image[colIdx][rowIdx]
--

Αρχικά αρχικοποιούμε με την συνάρτηση zeros της βιβλιοθήκης np μια εικόνα, όπως αντίστοιχα κάναμε και για το πρώτο μέρος της εργασίας.
Έπειτα τα βήματα είναι απλά, όπως και στο πρώτο μέρος της εργασίας θα πάρουμε ένα - ένα τα pixels της εικόνας. Έπειτα για κάθε pixel στην επανάληψη, με την χρήση της συνάρτησης https://docs.python.org/3/library/random.html[random()], της random της NumPY.
Η συνάρτηση αυτή μας δημιουργεί έναν τυχαίο πραγματικό αριθμό, by default στο διάστημα [0.0 1.0). Αν ο αριθμός αυτός είναι μικρότερος του 0.05, δίνουμε στο pixel την τιμή 0, δηλαδή μαύρο. Η πιθανότητα ο αριθμός να είναι μικρότερος της τιμής 0.05 είναι 5%.

Αν ο τυχαίος αριθμός που δημιουργήσαμε είναι μεγαλύτερος του αριθμού 0.95, επίσης δηλαδή πιθανότητα 5% να γίνει, ορίζουμε στο pixel την τιμή 255 δηλαδή απόλυτο άσπρο. Το αποτέλεσμα είναι τελικά στην εικόνα μας, να εμφανίζονται πολλά pixel με τιμή 0 και 255.
Αυτό είναι γνωστό ως το Salt & Pepper noise. Στο συγκεκριμένο παράδειγμα, η πιθανότητα ένα pixel να πάρει τιμή 0 ή 255 είναι 10%, δημιουργόντας έτσι ένα 10% Salt & Pepper noise.

Τέλος, αν ο αριθμός που δημιουργήσαμε είναι ανάμεσα στις τιμές 0.05 και 0.95, πιθανότητα 90%, κρατάει την αρχική του τιμή.
Σε κάθε περίπτωση, ορίζουμε στην νέα εικόνα μας τιμές 0,255, ή την τιμή του αντίστοιχου pixel στην αρχική εικόνα.

[Discrete]
==== Shot Noise

Παρακάτω ο κώδικας για την εισαγωγή του Shot θορύβου (Poisson):


