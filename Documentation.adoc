= Ψηφιακή Επεξεργασία Εικόνας - Εργασία 1
Ρούσου Αντρέι <cs171075@uniwa.gr>
:imagesdir: images
:toc: middle
:toc-title: Πίνακας Περιεχομένων
:source-highlighter: pygments

== Εισαγωγή

Η εργασία έγινε στα πλαίσια του μαθήματος Ψηφιακή Επεξεργασία Εικόνας κατά το ακαδημαικό έτος 2021-2022 και αποτελείται από δύο μέρη συνολικ

Στο πρώτο μέρος, στο πρώτο ερώτημα, γίνεται η ανάπτυξη μιας συνάρτησης, η οποία παίρνει δύο ορίσματα, την αρχική μας είκονα  και μια τιμή από 0 εώς 255. Η συνάρτηση μας με όνομα solarize κάνει ένα απλό pseudo-solarization, δηλαδή δίνοντας μια τιμή και την αρχική μας  εικόνα, όλα τα pixel της εικόνας με τιμή μεγαλύτερη ή ίση με το κατώφλι θα διατηρήσουν την τιμή που είχαν αρχικά, ενώ τα pixels με τιμή μικρότερη του κατωφλιού, θα αντικατασταθούν από pixel με τιμή το συμπλήρωμα του αρχικού, δηλαδή (255 - αρχική τιμή pixel). Αφού αναπτύξουμε την ζητούμενη συνάρτηση, ακολουθούν δυο ερωτήματα δοκιμής και αναπαράστασης των αποτελεσμάτων. 

Το δεύτερο ερώτημα αποτελείται από 3 δοκιμές της λειτουργίας της συνάρτησης μας δίνοντας ως κατώφλι τις τιμές 64, 128, 192. Πριν τις δοκιμές φυσικά η εικόνα μετατρέπεται σε grayscale ώστε να μήν έχουμε περισσότερα κανάλια χρώματος, αλλά μόνο το γκρι. Θα έχουμε ουσιαστικά μια ασπρόμαυρη εικόνα. Στην συνέχεια πάνω στην εικόνα μας, θα γίνει η δοκιμή με τις τιμές που δόθηκαν. 

Τέλος στο τρίτο και τελευταίο ερώτημα, θα γίνει η εμφάνιση και η αποθήκευση των αποτελεσμάτων μας.

== Μεθοδολογία - Μέρος Πρώτο

Παρακάτω η μεθοδολογία που ακολουθήσαμε  και τα αποτελέσματα που λαμβάνουμε για το πρώτο μέρος της εργασίας.

=== Κώδικας

Για το ζητούμενο του πρώτου ερωτήματος έγινε η ανάπτυξη του παρακάτω κώδικα:

.sabbatier.py
[source,python]
--
import cv2
import numpy as np


# Solarize function
def solarize(originalImage, thresValue):
    # Create solarized image, same resolution as original, all pixels value 0 of type uint8 (0-255)
    solarized_image = np.zeros(originalImage.shape, np.uint8)
    # shape returns a tuple of the number of rows, columns, and channels (if the image is color)
    # Select each pixel of the original image
    for colIdx in range(originalImage.shape[0]):
        for rowIdx in range(originalImage.shape[1]):
            # Check how the value of each pixel compares to our threshold value
            if originalImage[colIdx][rowIdx] >= thresValue:
                solarized_image[colIdx][rowIdx] = originalImage[colIdx][rowIdx]
            elif originalImage[colIdx][rowIdx] < thresValue:
                solarized_image[colIdx][rowIdx] = 255 - originalImage[colIdx][rowIdx]
    return solarized_image


# Read image
image = cv2.imread('VilleneuveMonaco1979.jpg')

# Convert from BGR to gray scale
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Show original and  gray scale image
cv2.namedWindow('Orig',cv2.WINDOW_NORMAL)
cv2.imshow('Orig', image)
cv2.namedWindow('Gray',cv2.WINDOW_NORMAL)
cv2.imshow('Gray', gray_image)

# Wait for any key, destroy all windows
# cv2.waitKey(0)
# cv2.destroyAllWindows()

# Save images
cv2.imwrite('Original.jpg', image)
cv2.imwrite('GrayScaleImg.jpg', gray_image)

# Solarize using thresValue = 64
solarized_img64 = solarize(gray_image, 64)

# Solarize using thresValue = 128
solarized_img128 = solarize(gray_image, 128)

# Solarize using thresValue = 192
solarized_img192 = solarize(gray_image, 192)

# Show solarized images
cv2.namedWindow('Solarized image [64]',cv2.WINDOW_NORMAL)
cv2.imshow('Solarized image [64]', solarized_img64)
cv2.namedWindow('Solarized image [128]',cv2.WINDOW_NORMAL)
cv2.imshow('Solarized image [128]', solarized_img128)
cv2.namedWindow('Solarized image [192]',cv2.WINDOW_NORMAL)
cv2.imshow('Solarized image [192]', solarized_img192)

#Save images
cv2.imwrite('Solarized64.jpg', solarized_img64)
cv2.imwrite('Solarized128.jpg', solarized_img128)
cv2.imwrite('Solarized192.jpg', solarized_img192)

# Wait for any key, destroy all windows
cv2.waitKey(0)
cv2.destroyAllWindows()
--


=== Ζητούμενο 1

Η συνάρτηση που ζητήθηκε για το πρώτο ερώτημα είναι η παρακάτω:

[source, python]
--
# Solarize function
def solarize(originalImage, thresValue):
    # Create solarized image, same resolution as original, all pixels value 0 of type uint8 (0-255)
    solarized_image = np.zeros(originalImage.shape, np.uint8)
    # shape returns a tuple of the number of rows, columns, and channels (if the image is color)
    # Select each pixel of the original image
    for colIdx in range(originalImage.shape[0]):
        for rowIdx in range(originalImage.shape[1]):
            # Check how the value of each pixel compares to our threshold value
            if originalImage[colIdx][rowIdx] >= thresValue:
                solarized_image[colIdx][rowIdx] = originalImage[colIdx][rowIdx]
            elif originalImage[colIdx][rowIdx] < thresValue:
                solarized_image[colIdx][rowIdx] = 255 - originalImage[colIdx][rowIdx]
    return solarized_image
--

Η συνάρτηση μας δέχεται δύο ορίσματα, όπως αυτά ζητήθηκαν, την αρχική μας εικόνα και μια τιμή thresValue. Κατά την εκτέλεση της συνάρτησης μας, δημιουργούμε μια εικόνα με όνομα solarized_image, η οποία θα αποτελεί την εικόνα που θα επιστρέψει η συνάρτηση μας.
Η αρχικοποίηση της εικόνας μας, γίνεται με μηδενικά bit με την χρήση της συνάρτησης https://numpy.org/doc/stable/reference/generated/numpy.zeros.html[zeros] της βιβλιοθήκης https://numpy.org/[numpy], 
αρχικοποιόντας έτσι την εικόνα μας, με μηδενικά bit, σε ίδιο μέγεθος με την αρχική εικόνα που δίνουμε για όρισμα. Δίνουμε στην συνάρτηση zeros μας και τον τύπο δεδομένων uint8, unsigned integer των 8-bit δηλαδή, εύρως τιμών 0 εώς 255, δηλαδή οι τιμές
που μπορεί να πάρει ένα pixel. 

Έχει ενδιαφέρον να γίνει μια ανάλυση της συνάρτησης shape. Η συνάρτηση αυτή επιστρέφει ένα tupple με 3 στοιχεία, των αριθμό των γραμμών, των στυλών και τέλος τα κανάλια. Αυτό έχει σημασία διότι με ευκολία μπορούμε με μια for να πάρουμε κάθε γραμμή της εικόνας και με
μια άλλη for κάθε στύλη, όπως ακριβώς θα κάναμε αν θέλαμε να έχουμε πρόσβαση σε κάθε στοιχείο ενός πίνακα δυο διαστάσεων. 

Αφού λοιπόν μπορούμε να το κάνουμε αυτό, μένει μόνο να συγκρίνουμε την τιμή του κάθε pixel της αρχικής εικόνας με την τιμή που έχουμε δώσει για
το κατώφλι. Αν είναι μεγαλύτερη, το pixel κρατάει την τιμή που είχε, δηλαδή στην νέα εικόνα μας κάνουμε εκχώρηση της τιμής του pixel της αρχικής εικόνας στο αντίστοιχο pixel της εικόνας που θα επιστρέψει η συνάρτηση μας.
Αλλίως, αν είναι μικρότερη, εκχωρούμε στο pixel την τιμή (255 - την τιμή του pixel της αρχικής εικόνας), το συμπλήρωμα δηλαδή όπως ζητήθηκε στην εκφώνηση. Τέλος φυσικά αφού έχει γίνει ο έλεγχος σε κάθε pixel, η συνάρτηση μας επιστρέψει την solarized εικόνα μας.





== Μέρος Δεύτερο

